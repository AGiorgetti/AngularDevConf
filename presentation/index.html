<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">

    <title>AngularJS Dev Conf - Scopes &and; Directives</title>

    <meta name="description" content="">
    <meta name="author" content="">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/night.css" id="theme">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- If the query includes 'print-pdf', use the PDF print sheet -->
    <script>
        document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
    </script>

    <!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
</head>

<body>

    <div class="reveal">

        <!-- Any section element inside of this container is displayed as a slide -->
        <div class="slides">
            <section>
                <h1>AngularJS</h1>
                <h3>Scope e Direttive</h3>
                <p>
                    <big>Speaker:
                        <a href="http://www.rimordialcode.com">Alessandro Giorgetti</a> /
                        <a href="http://twitter.com/a_giorgetti">@a_giorgetti</a>
                    </big>
                </p>
                <br />
                <br />
                <br />
                <small>pick a theme: <a href="?theme=night">night</a> or <a href="?theme=blood">blood</a></small>
            </section>

            <section>
                <section>
                    <h2>Scope</h2>
                    <ul>
                        <li class="fragment">Collante tra il modello e la UI, costituiscono il contesto di binding.</li>
                        <li class="fragment">Costituiscono il contesto di esecuzione per la valutazione di espressioni.</li>
                        <li class="fragment">Hanno struttura gerarchica, simile a quella del DOM.</li>
                        <li class="fragment">Forniscono API per osservare lo stato di oggetti ed espressioni ($watch). </li>
                        <li class="fragment">Forniscono API per propagare cambiamenti di stato del modello generati al di fuori del normale ciclo di esecuzione di Angular ($apply)</li>
                        <li class="fragment">Forniscono API per generare, propagare e gestire eventi ($broadcast, $emit, $on).</li>
                    </ul>

                    <aside class="notes">
                        can see them if you open the speaker notes window (hit 's' on your keyboard).
                    </aside>
                </section>
                <section>
                    <h2>Scope</h2>
                    <ul>
                        <li class="fragment">Ogni applicazione Angular ha 1 solo <strong>$rootScope</strong>.</li>
                        <li class="fragment">E' comunque possibile creare nuovi Scope programmaticamente.</li>
                        <li class="fragment">Quando un nuovo scope viene creato a partire da un'altro scope si parla di
                            <b>Child Scope</b>.</li>
                        <li class="fragment">Alcune direttive possono richiedere la creazione di Child Scope (ex: ng-controller).</li>
                        <li class="fragment">Gli scope costituiscono una struttura ad albero che ha la sua radice nello $rootScope.</li>
                        <li class="fragment">
                            <b>Ad ogni nodo del DOM pu&ograve; essere associato 1 ed 1 solo scope.</b>
                        </li>
                    </ul>

                </section>
                <section>
                    <h2>Child Scope / Inherited Scope</h2>
                    <ul>
                        <li class="fragment">I Child Scope ereditano il prototipo del loro scope parent (<b>prototypical inheritance</b>).</li>
                        <li class="fragment">Quando AngularJS deve valutare una espressione inizia dallo scope a cui l'elemento è associato.</li>
                        <li class="fragment">Se la proprietà non viene trovata si passa ad analizzare il parent, e così via.</li>
                    </ul>
                    <br />
                    <br />
                    <p class="fragment">Demo!</p>

                    <aside class="notes">
                        - mostrare 01 - illustrare l'esempio - vedere scope nidificati - illustrare i dati su rootscope
                    </aside>
                </section>
                <section>
                    <h2>Scope</h2>
                    <p>Informazioni dettagliate a questo
                        <a href="http://docs.angularjs.org/guide/scope">link</a> della guida di AngularJS</p>
                </section>
            </section>

            <section> 
                <section>
                    <h2>Directive (Direttiva)</h2>
                    <ul>
                        <li class="fragment">Consentono di estendere le possibilità dell'html classico abilitando la creazione di veri e propri
                        <b>Web Controls</b>. </li>
                        <li class="fragment">Le direttive sono dei
                        <strong>marker</strong> su un elemento del DOM (css class, attributo, elemento/tag) che indicano al 'compilatore HTML' di Angular come trasformare gli elementi del DOM e quali comportamenti aggiungere.</li>
                        <li class="fragment">Angular fornisce un set predefinito (in espansione) di direttive che consentono di rendere interattiva la pagina HTML (ngModel, ngController, ngBind, ngRepeat, ...).</li>
                    </ul>
                </section>
                <section>
                    <h2>Una direttiva si fa cos&igrave;:</h2>
                    <pre><code>
var myModule = angular.module(...);
myModule.directive('directiveName', function factory(injectables) {
  var directiveDefinitionObject = {
    priority: 0,
    terminal: false,
    template: '<div></div>', // or // function(tElement, tAttrs) { ... },
    // or
    // templateUrl: 'directive.html', // or // function(tElement, tAttrs) { ... },
    replace: false,
    transclude: false,
    restrict: 'A',
    scope: false,
    controller: function($scope, $element, $attrs, $transclude, otherInjectables) { ... },
    require: 'siblingDirectiveName', // or // ['^parentDirectiveName', '?optionalDirectiveName', '?^optionalParent'],
    compile: function compile(tElement, tAttrs, transclude) {
      return {
        pre: function preLink(scope, iElement, iAttrs, controller) { ... },
        post: function postLink(scope, iElement, iAttrs, controller) { ... }
      }
      // or
      // return function postLink( ... ) { ... }
    },
    // or
    // link: {
    //  pre: function preLink(scope, iElement, iAttrs, controller) { ... },
    //  post: function postLink(scope, iElement, iAttrs, controller) { ... }
    // }
    // or
    // link: function postLink( ... ) { ... }
  };
  return directiveDefinitionObject;
});
</code></pre>
                </section>
                <section>
                    <h2>La nostra 1° direttiva</h2>
                    <p>Aggiungiamo comportamento ad un tag &lt;input&gt;</p>
                    <pre><code>
.directive('selectOnFocus', function () {
        return {
            restrict: 'A',
            link: function(scope, iElement) {
                iElement.mouseup(function(evt) {
                    evt.preventDefault();
                });
                iElement.focus(function() {
                    iElement.select();
                });
            }
        }
    })
</code></pre>
                    <p style="text-align: left">Introducing:</p>
                        <ul style="font-size: 30px">
                            <li><strong>directive</strong> - dichiarare una direttiva.</li>
                            <li><strong>restrict (E, A, C, M)</strong> - impone restrizioni sulla modalità di dichiarazione.</li>
                            <li><strong>link(scope, iElement, iAttrs, controller, transcludeFn){...}</strong> - aggiungere comportamento al DOM: registra gli event handler ed è responsabile dell'aggiornamento del DOM.</li>
                        </ul>  
                </section>
                <section>
                    <h2>The link() function</h2>
                    <p style="text-align: left">argomenti:</p>
                    <ul>
                        <li class="fragment">scope - lo scope usato dalla direttiva.</li>
                        <li class="fragment">iElement - elemento del DOM a cui la direttiva è collegata.</li>
                        <li class="fragment">iAttrs - lista degli attributi dichiarati sull'elemento (condivisa tra tutte le direttive applicate sullo stesso elemento).</li>
                        <li class="fragment">controller - lista dei controller associati alle direttive applicate allo stesso elemento.</li>
                        <li class="fragment">transcludeFn - A transclude linking function pre-bound to the correct transclusion scope. ?!? WHAT THE H... ?!?</li>
                    </ul> 
                    <br />
                    <br />
                    <p class="fragment">Demo!</p>
                </section>
                <section>
                    <h2>La nostra 2° diretiva (hardcoded widget)</h2>
                    <p>Iniziamo da del markup per una form di immissione dati usando Bootstrap</p>
                    <pre class="fragment"><code data-trim>
angular.module('myDirectives', [])
    .directive('myLabelInput', function () {
        return {
            restrict: 'EA',
            replace: true,
            template: '<div class="form-group">' +
                      '<label for="exampleInputEmail1">Email address</label>' +
                      '<input type="email" class="form-control" id="exampleInputEmail1" placeholder="Enter email" ng-model="data.email">' +
                      '</div>'
        }
    });
</code></pre>
                    <p>introducing: <strong>replace</strong> &amp; <strong>template</strong></p>
                    <p class="fragment">Demo!</p>
                </section>
                <section>
                    <h2>Make it reusable: isolated scope</h2>
                    <p style="font-size: 24px; text-align: left">Consentire alle direttive di creare i propri scope è fondamentale per creare componenti che siano riutilizzabili sfruttanto il meccanismo dei binding senza dover 'impazzire' nel gestire la comunicazione con l'esterno tramite attributi.</p>
                    <pre><code>
.directive('myLabelInput2', function () {
            return {
                restrict: 'EA',
                replace: true,
                scope: { // isolated scope!!! (it does not inherits the scope from its enclosing scope).
                    id: '@', // one-way binding
                    type: '@',
                    placeholder: '@',
                    ngModel: '=' // two-way binding
                },
                template: '<div class="form-group">' +
                    '<label for="{{ id }}">{{ placeholder }}</label>' +
                    '<input type="{{ type }}" class="form-control" id="{{ id }}" placeholder="{{ placeholder }}" data-ng-model="ngModel" data-select-on-focus="">' +
                    '</div>'
            };
        });
</code></pre>
                    <p style="font-size: 30px">introducing: <strong>isolated scope</strong> - gli scope isolati non ereditano il prototipo del parent scope, serve a prevenire leak di dati e ad evitare modifiche accidentali dei dati sui parent scope.</p>
                </section>
                <section>
                    <h3>Passare parametri allo Scope</h3>
                    <p style="font-size: 20px; text-align: left">il passaggio di parametri avviene dichiarativamente dal template HTML verso le proprietà definite sullo scope:</p>
                        <pre><code>scope: {
    oneWayExpression: '@',
    twoWayBinding: '=',
    oneWayBehavior: '&amp;'
} 

&lt;div my-directive
    one-way-expression="questa espressione viene valutata: {{ i++ }}"
    two-way-binding="variabile"
    one-way-behavior="func(variabile)" &gt;
&lt;/div&gt;
</code></pre>
                    <ul style="font-size: 20px">
                    <li class="fragment"><b>@</b> - binding tra la variabile sullo isolated scope ed il valore di un attributo sul DOM (eventualmente una espressione che viene valutata, il risultato è una stringa).</li>
                    <li class="fragment"><b>=</b> - binding bidirezionale tra la propriet&agrave; definita sullo scope isolato della direttiva e la proprietà associata allo scope esterno (definita mediante attributo sul template).</li>
                    <li class="fragment"><b>&amp;</b> - metodo per eseguire funzioni e valutare espressioni nel contesto del chiamante: è possibile passare parametri alla funzione definita sul parent scope utilizzando una mappatura dei parametri, ex: func(variabile) può essere invocata come: $scope.oneWayBehavior({ variabile: 'xxx'}).
                    </ul></li>
                <p class="fragment">Demo!</p>
                </section>
                <section>
                    <h2>The compile() function</h2>
                    <div style="text-align: left">
                    <p>Se si devono eseguire operazioni sul DOM o alterare il template della direttiva è buona norma usare la funzione 'compile'.</p>
                    <p>Argomenti:</p>
                    <ul>
                        <li>iElement</li>
                        <li>iAttrs</li>
                    </ul>
                        <p class=fragment>Se si usa la funzione compile e si vuole renedere la direttiva dinamica (utilizzando uno scope) occorre far ritornare una link function ed eseguire la compilazione ed il linking allo scope manualmente usando il servizio $compile messo a disposizione da AngularJS</p>
                    </div>
                    <p>Introducing: <strong>compile</strong></p>
                    <br />
                    <br />
                    <p class="fragment">Demo!</p>
                </section>
                <section>
                    <h2>Transclusion</h2>
                    <p class="fragment">'Parolona' per indicare una cornice (frame).</p>
                    <br />
                    <p class="fragment">Consente di iniettare contenuto (tag html, templates, etc) all'interno del template di una direttiva gi&agrave; esistente senza dover operare ricorrendo alla funzione 'compile' vista in precedenza.</p>
                    <pre class="fragment"><code>
.directive('myCenteredFrame', function () {
            return {
                restrict: 'EA',
                transclude: true,
                //replace: true,
                template: '&lt;div class="row"&gt;' +
                          '&lt;div ng-transclude class="col-xs-8 col-xs-offset-2">&lt;/div&gt;' + 
                          '&lt;/div&gt;'
            };
        })</code></pre>
                    <p>Introducing: <strong>transclude</strong> &amp; <strong>ng-transclude</strong></p>
                    <p class="fragment">Demo!</p>
                </section>
                <section>
                    <h2>Controller</h2>
                    <p style="text-align: left">Le direttive possono avere necessit&agrave; di comunicare tra loro, possono farlo tramite:</p>
                    <ul>
                        <li class="fragment">Attributi sul DOM (denormalizzati e accessibili l'oggetto 'attrs' sulle funzioni compile e link (roba gi&agrave; vista).</li>
                        <li class="fragment">Associando un 'controller' alla direttiva ed eseguendo il 'require' di altre direttive sullo stesso nodo se si vuole accedere ai loro controller.</li>
                    </ul>
                    <br />
                    <br />
                    <p class="fragment">La funzione che definisce il controller pu&oacute; accettare dei parametri risolti con dependency injection.</p>
                    <br />
                    <br />
                    <p>Introducing: <strong>controller</strong> &amp; <strong>require</strong></p>
                    <p class="fragment" style="font-size: 26px">Nell'ordine di esecuzione delle funzioni il controller viene istanziato PRIMA della chiamata alle pre-linking functions. Consente alle direttive di comunicare e modificare il comportamento l'una dell'altra.</p>
                    <p class="fragment" style="font-size: 26px">Demo: Take a look at the 'myTabs &amp; myPane' sample directives!</p>
                </section>
                <section>
                    <h2>Ancora due cose:</h2>
                    <ul>
                        <li class="fragment"><b>priority</b> - imposta ordine di priorità nell'esecuzione delle direttive: maggiore il numero più alta la priorità. All'interno della stessa priorità l'ordine di esecuzione non è garantito.</li>
                        <li class="fragment"><b>terminal</b> - arresta l'esecuzione delle direttive sull'ordine di priorità della direttiva corrente: direttive con priorità inferiore non vengono eseguite.</li>
                        <br />
                        <br />
                        <p class="fragment">No Demo this time!</p>
                    </ul>
                </section>
            </section>
            <section>
                <h2>That's it!&nbsp;&nbsp;&nbsp;Q &amp; A time!</h2>
                <br />
                <br />
                <div style="text-align: right">
                    <p>Contacts:</p>
                    Mail: <a href="mailto:alessandro.giorgetti@live.com">alessandro.giorgetti@live.com</a><br />
                    Blog: <a href="http://www.rimordialcode.com">PrimordialCode</a><br />
                    Twitter: <a href="http://twitter.com/a_giorgetti">@a_giorgetti</a><br />
                    Facebook: <a href="https://www.facebook.com/giorgetti.alessandro">myself</a><br />
                    LinkedIn: <a href="http://www.linkedin.com/in/giorgettialessandro">myself again</a><br />
                    Google+: <a href="https://plus.google.com/+AlessandroGiorgetti74">and again</a>
                </div>
            </section>
        </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>

    <script>
        // Full list of configuration options available here:
        			// https://github.com/hakimel/reveal.js#configuration
        			Reveal.initialize({
        				controls: true,
        				progress: true,
        				history: true,
        				center: true,
        
        				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none
        
        				// Parallax scrolling
        				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
        				// parallaxBackgroundSize: '2100px 900px',
        
        				// Optional libraries used to extend on reveal.js
        				dependencies: [
        					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
        					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
        					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
        					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
        				]
        			});
    </script>

</body>

</html>
